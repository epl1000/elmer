from config import PCBParams


def generate_geo(params: PCBParams) -> str:
    g_size = params.ground_size
    g_thk = params.ground_thickness
    sep = params.separation
    t_thk = params.trace_thickness
    t_width = params.trace_width
    t_length = params.trace_length
    v_width = params.via_width
    v_depth = params.via_depth
    gv_width = params.guard_via_width
    sph_rad = params.sphere_radius
    mesh_min = params.mesh_size_min
    mesh_max = params.mesh_size_max
    cut_w = params.cut_width
    cut_h = params.cut_height

    template = f"""//******************************************************
// PCB Model - Generated by PCB GMSH Generator
//******************************************************

SetFactory(\"OpenCASCADE\");
Geometry.OCCSewFaces      = 1;
Geometry.OCCFixSmallEdges = 1;
Geometry.OCCFixSmallFaces = 1;
Geometry.OCCAutoFix       = 1;
Geometry.Tolerance        = 1e-8;

//------------------------- 1) Parameters -------------------------//
ground_size      = {g_size};
ground_thickness = {g_thk};
separation       = {sep};
trace_thickness  = {t_thk};
trace_width      = {t_width};
trace_length     = {t_length};
via_width        = {v_width};
via_depth        = {v_depth};
sphere_radius    = {sph_rad};

z0_ground_bot    = 0.0;
z1_ground_top    = z0_ground_bot + ground_thickness;
z2_trace_bot     = z1_ground_top + separation;
z3_trace_top     = z2_trace_bot + trace_thickness;
via_z_bot        = z1_ground_top - 1e-5;
via_z_top        = z3_trace_top;
eps              = 1e-6;

//------------------------- 2) Create Geometry -------------------------//
// Ground plane (Box 1)
Box(1) = {{
  -ground_size/2, -ground_size/2, z0_ground_bot,
   ground_size,    ground_size,    ground_thickness
}};

// *** ADDED: rectangular cut only through the ground plane ***
// We'll center it under the trace.
cut_w = {cut_w};
cut_h = {cut_h};
x_cut_center = -5.0 + trace_length/2;
y_cut_center = 0.0;

// Create the cut box (Box 10)
Box(10) = {{
  x_cut_center - cut_w/2,
  y_cut_center - cut_h/2,
  z0_ground_bot,
  cut_w,
  cut_h,
  ground_thickness
}};

// Replace Volume(1) with a difference: ground minus the new cut
cutRes[] = BooleanDifference{{ Volume{{1}}; Delete; }}{{ Volume{{10}}; Delete; }};
// Rename that difference back to volume #1
SetId{{ Volume{{cutRes[0]}} }} 1;
// *** END ADDED LINES ***

// Main via (Box 2)
Box(2) = {{
  4.8, -0.1, via_z_bot,
  via_width, via_depth, (via_z_top - via_z_bot - eps)
}};

// Trace (Box 3)
Box(3) = {{
  -5.0, -trace_width/2, z2_trace_bot + eps,
   trace_length, trace_width, trace_thickness - 2*eps
}};

// Bounding sphere (Sphere 4)
Sphere(4) = {{ 0, 0, 0, sphere_radius }};

// Guard vias (Boxes 5 to 8)
x1 = -5.0 + trace_length/3.0;
x2 = -5.0 + 2.0*(trace_length/3.0);
Box(5) = {{
  x1, -0.4, via_z_bot,
  {gv_width}, {gv_width}, (via_z_top - via_z_bot - eps)
}};
Box(6) = {{
  x1,  0.2, via_z_bot,
  {gv_width}, {gv_width}, (via_z_top - via_z_bot - eps)
}};
Box(7) = {{
  x2, -0.4, via_z_bot,
  {gv_width}, {gv_width}, (via_z_top - via_z_bot - eps)
}};
Box(8) = {{
  x2,  0.2, via_z_bot,
  {gv_width}, {gv_width}, (via_z_top - via_z_bot - eps)
}};

// *** Added for dielectric ***
// This box fills the entire XY footprint of the PCB,
// from the top of the ground plane to the bottom of the trace.
Box(9) = {{
  -ground_size/2, -ground_size/2, z1_ground_top,
   ground_size,    ground_size,   (z2_trace_bot - z1_ground_top)
}};

//------------------------- 3) Boolean Operations -------------------------//
// Step 1: Fuse all vias together into a single volume array
vias_all[] = BooleanUnion{{Volume{{2}}; Delete; }}{{ Volume{{5,6,7,8}}; Delete; }};
Printf("Vias fusion result -> new volume(s): %g", vias_all[0]);

// Step 2: Union ground plane with all vias
ground_vias[] = BooleanUnion{{Volume{{1}}; Delete; }}{{ Volume{{vias_all[]}}; Delete; }};
Printf("Ground+Vias fusion result -> new volume(s): %g", ground_vias[0]);

// The trace is still Volume #3 by default
trace = 3;
Printf("Trace volume: %g", trace);

// Subtract ground+vias and the trace from Box(9)
// so the dielectric occupies only the gap.
dielectric[] = BooleanDifference{{ Volume{{9}}; Delete; }}{{ Volume{{ground_vias[], trace}}; }};
Printf("Dielectric volume result -> new volume(s): %g", dielectric[0]);

// Step 3: Subtract the PCB volumes (ground_vias, trace, dielectric) from the bounding sphere (#4)
// to define the air region surrounding everything.
air[] = BooleanDifference{{ Volume{{4}}; Delete; }}{{ Volume{{ground_vias[], trace, dielectric[]}}; }};
Printf("Air volume result -> new volume(s): %g", air[0]);

// Ensure geometry is consistent
Coherence;

//------------------------- 4) Define Physical Volumes -------------------------//
//   ground_vias[]  -> the union of ground plane + all vias (ID = 1)
//   trace (which is volume #3, ID = 2)
//   dielectric[]   -> new volume for the gap (ID = 4)
//   air[]          -> bounding sphere minus the PCB (ID = 3)

Physical Volume("Ground and Vias", 1) = {{ ground_vias[] }};
Physical Volume("Trace", 2)          = {{ trace }};
Physical Volume("Dielectric", 3)     = {{ dielectric[] }};
Physical Volume("Air", 4)            = {{ air[] }};

// Define the important surfaces for boundary conditions
Physical Surface("Ground Bottom", 11) = {{5}}; // Bottom of ground plane
Physical Surface("Air Boundary", 12) = {{6}}; // Outer surface of air volume

//------------------------- 5) Mesh Settings -------------------------//
Point(200) = {{ 0, 0, z1_ground_top, 0.05 }};
Point(201) = {{ 4.8 + via_width/2, 0, via_z_bot, 0.05 }};
Point(202) = {{ x1, 0, via_z_bot, 0.05 }};
Point(203) = {{ x2, 0, via_z_bot, 0.05 }};
Point(204) = {{ -5.0 + trace_length/2.0, 0, z2_trace_bot, 0.05 }};

Field[1] = Distance;
Field[1].PointsList = {{200, 201, 202, 203, 204}};
Field[2] = MathEval;
Field[2].F = "0.05 + 0.1 * F1";
Field[3] = Min;
Field[3].FieldsList = {{2}};
Background Field = 3;

Mesh.Algorithm = 6;
Mesh.Algorithm3D = 10;
Mesh.OptimizeNetgen = 1;
Mesh.Optimize = 1;
Mesh.CharacteristicLengthMax = {mesh_max};
Mesh.CharacteristicLengthMin = {mesh_min};

// Uncomment the following lines to auto-generate the mesh
//Generate 3;
//Save \"pcb_model.msh\";

// Add helpful comments for Elmer import
Printf("//");
Printf("// IMPORTANT: When importing into Elmer, you should see exactly four volumes:");
Printf("// 1. Ground and Vias (ID 1)");
Printf("// 2. Trace (ID 2)");
Printf("// 3. Air (ID 3)");
Printf("// 4. Dielectric (ID 4)");
Printf("//");
"""
    return template

